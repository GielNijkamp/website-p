{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/gieln/code/projects/website/gnijkamp/src/app/three/NeuralCore.tsx"],"sourcesContent":["// app/three/NeuralCore.tsx\r\n'use client'\r\nimport { Canvas, useFrame } from '@react-three/fiber'\r\nimport { useRef, useMemo, useLayoutEffect } from 'react'\r\nimport * as THREE from 'three'\r\n\r\n// A component to encapsulate the neural core art\r\nexport function NeuralCore() {\r\n  const groupRef = useRef<THREE.Group>(null!)\r\n  \r\n  // Build your icosahedron geometry and compute particle count.\r\n  const icosahedron = useMemo(() => new THREE.IcosahedronGeometry(80, 2), [])\r\n  const vertices = icosahedron.attributes.position.array as Float32Array;\r\n  const particleCount = icosahedron.attributes.position.count\r\n\r\n  // Main particle instanced mesh reference\r\n  const particlesRef = useRef<THREE.InstancedMesh>(null!)\r\n  const dummy = useMemo(() => new THREE.Object3D(), [])\r\n\r\n  // Initialize particle positions using the vertices of the icosahedron.\r\n  useLayoutEffect(() => {\r\n    for (let i = 0; i < particleCount; i++) {\r\n      dummy.position.set(\r\n        vertices[i * 3],\r\n        vertices[i * 3 + 1],\r\n        vertices[i * 3 + 2]\r\n      )\r\n      dummy.updateMatrix()\r\n      particlesRef.current.setMatrixAt(i, dummy.matrix)\r\n    }\r\n    particlesRef.current.instanceMatrix.needsUpdate = true\r\n  }, [particleCount, vertices, dummy])\r\n\r\n  // Prepare custom shader material for signal particles\r\n  const signalMaterial = useMemo(() => new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      time: { value: 0 },\r\n      intensity: { value: 1.0 }\r\n    },\r\n    vertexShader: `\r\n      varying float vLife;\r\n      varying vec3 vPosition;\r\n      void main() {\r\n        // You can use instanceMatrix data to drive animation\r\n        vLife = instanceMatrix[3][3];\r\n        vPosition = position;\r\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\r\n      }\r\n    `,\r\n    fragmentShader: `\r\n      uniform float time;\r\n      uniform float intensity;\r\n      varying float vLife;\r\n      void main() {\r\n        float pulse = sin(vLife * 20.0 + time * 5.0) * 0.5 + 0.5;\r\n        vec3 color = vec3(1.0, 0.2, 0.2) * intensity * (1.0 + pulse * 0.5);\r\n        float alpha = smoothstep(0.0, 0.2, vLife) * smoothstep(1.0, 0.8, vLife);\r\n        gl_FragColor = vec4(color, alpha * 1.2);\r\n      }\r\n    `,\r\n    transparent: true,\r\n    blending: THREE.AdditiveBlending\r\n  }), [])\r\n\r\n  // For simplicity, create a small number of signal particles.\r\n  const signalCount = 150\r\n  const signalParticlesRef = useRef<THREE.InstancedMesh>(null!)\r\n\r\n  // Setup beams and connections similarly using BufferGeometry and ShaderMaterial...\r\n  // (Omitted here for brevity. You would create a BufferGeometry for beams, set attributes, etc.)\r\n\r\n  // Animate the scene – update shader uniforms and instance matrices\r\n  useFrame((state) => {\r\n    const time = state.clock.getElapsedTime()\r\n    signalMaterial.uniforms.time.value = time\r\n    // Add your animation logic here:\r\n    // • Update signalParticles matrices\r\n    // • Animate beams geometry attributes\r\n    // • Optionally, rotate the entire neural core group\r\n    if (groupRef.current) {\r\n      groupRef.current.rotation.x += 0.0005 * Math.sin(time * 0.1)\r\n      groupRef.current.rotation.y += 0.0005 * Math.cos(time * 0.1)\r\n      groupRef.current.rotation.z += 0.0003 * Math.sin(time * 0.1)\r\n    }\r\n  })\r\n\r\n  return (\r\n    <group ref={groupRef}>\r\n      {/* Main particles instanced mesh */}\r\n      <instancedMesh\r\n        ref={particlesRef}\r\n        args={[\r\n          // Geometry for each particle\r\n          new THREE.SphereGeometry(0.6, 8, 8),\r\n          // Material for main particles\r\n          new THREE.MeshBasicMaterial({\r\n            color: 0xffff00,\r\n            transparent: true,\r\n            opacity: 0.9,\r\n            blending: THREE.AdditiveBlending\r\n          }),\r\n          particleCount\r\n        ]}\r\n      />\r\n      {/* Signal particles with custom shader */}\r\n      <instancedMesh\r\n        ref={signalParticlesRef}\r\n        args={[\r\n          new THREE.SphereGeometry(1.2, 32, 32),\r\n          signalMaterial,\r\n          signalCount\r\n        ]}\r\n      />\r\n      {/* Add beams and connections as separate components or groups here */}\r\n    </group>\r\n  )\r\n}\r\n\r\n// A Canvas wrapper component for your scene\r\nexport default function NeuralScene() {\r\n  return (\r\n    <Canvas\r\n      camera={{ position: [0, 0, 250], fov: 75 }}\r\n      style={{ width: '100vw', height: '100vh' }}\r\n    >\r\n      {/* Set the background color */}\r\n      <color attach=\"background\" args={['#0e0e1a']} />\r\n      <NeuralCore />\r\n      {/* Optionally add controls, lights, etc. */}\r\n    </Canvas>\r\n  )\r\n}"],"names":[],"mappings":"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","debugId":null}}]
}